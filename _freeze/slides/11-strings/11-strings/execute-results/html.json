{
  "hash": "b703f2b51921505f356288a5af68c705",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Strings\"\nsubtitle: \"Lecture 11\"\ntitle-slide-attributes:\n  data-background-image: ../vizdata-bg.png\n  data-background-size: stretch\n  data-slide-number: none\nformat: revealjs\n---\n\n\n::: {.cell}\n\n:::\n\n\n# Introduction\n\n## Working with Strings\n\n- Text data, or \"strings\", are very common.\n- The `stringr` package, part of the `tidyverse`, provides a modern and consistent interface for working with strings.\n- All functions in `stringr` start with `str_`.\n\n# Creating Strings\n\n## Basics\n\n- You can create strings with single (`'`) or double (`\"`) quotes.\n- To include a literal quote in your string, you need to \"escape\" it with a `\\`.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nstring1 <- \"This is a string.\"\nstring2 <- 'If I want to include a \"quote\", I can.'\nstring3 <- \"Or I can escape it like this \\\"\"\n\nstr_view(c(string1, string2, string3))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] │ This is a string.\n[2] │ If I want to include a \"quote\", I can.\n[3] │ Or I can escape it like this \"\n```\n\n\n:::\n:::\n\n\n## Combining Strings: `str_c()`\n\n- `str_c()` combines multiple vectors into a single character vector.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nstr_c(\"x\", \"y\", \"z\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"xyz\"\n```\n\n\n:::\n\n```{.r .cell-code}\nstr_c(\"x\", \"y\", c(\"a\", \"b\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"xya\" \"xyb\"\n```\n\n\n:::\n:::\n\n\n## Gluing Strings: `str_glue()`\n\n- `str_glue()` from the `glue` package is great for embedding R code inside a string.\n- Wrap your R code in `{}`.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code  code-fold=\"true\"}\nname <- \"Fred\"\nage <- 50\nanniversary <- as.Date(\"2025-12-30\")\n\nstr_glue(\n  \"My name is {name}, \",\n  \"my age is {age}, \",\n  \"and my anniversary is {format(anniversary, '%A, %B %d, %Y')}.\"\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nMy name is Fred, my age is 50, and my anniversary is Tuesday, December 30, 2025.\n```\n\n\n:::\n:::\n\n\n# Practice\n\nLet's practice working with strings!\n\n# Extracting Data\n\n## Separating into Columns\n\n- `tidyr::separate_wider_delim()` splits a column into multiple new columns based on a delimiter.\n- You must provide names for the new columns.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ndf <- tibble(x = c(\"a_b_1\", \"c_d_2\", \"e_f_3\"))\ndf |> separate_wider_delim(\n  x,\n  delim = \"_\",\n  names = c(\"first\", \"second\", \"third\")\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 3 × 3\n  first second third\n  <chr> <chr>  <chr>\n1 a     b      1    \n2 c     d      2    \n3 e     f      3    \n```\n\n\n:::\n:::\n\n\n## Separating into Rows\n\n- `tidyr::separate_longer_delim()` splits a column into multiple new rows.\n- Useful when each cell contains a varying number of items.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ndf <- tibble(x = 1:2, y = c(\"a,b\", \"c,d,e\"))\ndf |> separate_longer_delim(y, delim = \",\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 5 × 2\n      x y    \n  <int> <chr>\n1     1 a    \n2     1 b    \n3     2 c    \n4     2 d    \n5     2 e    \n```\n\n\n:::\n:::\n\n\n# Working with Letters\n\n## Length\n\n- `str_length()` gives you the number of characters in a string.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nstr_length(c(\"a\", \"R for data science\", NA))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1]  1 18 NA\n```\n\n\n:::\n:::\n\n\n## Subsetting\n\n- `str_sub()` extracts a part of a string.\n- You provide the `start` and `end` positions (inclusive).\n- Negative numbers count from the end of the string.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nx <- c(\"Apple\", \"Banana\", \"Pear\")\nstr_sub(x, 1, 3)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"App\" \"Ban\" \"Pea\"\n```\n\n\n:::\n\n```{.r .cell-code}\nstr_sub(x, -2, -1)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"le\" \"na\" \"ar\"\n```\n\n\n:::\n:::\n\n\n## Case\n\n- `str_to_lower()`: convert to lowercase.\n- `str_to_upper()`: convert to uppercase.\n- `str_to_title()`: convert to title case.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nstr_to_lower(\"I am shouting.\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"i am shouting.\"\n```\n\n\n:::\n\n```{.r .cell-code}\nstr_to_title(\"a tale of two cities\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"A Tale Of Two Cities\"\n```\n\n\n:::\n:::\n\n\n## Whitespace\n\n- `str_trim()` removes whitespace from the start and end of a string.\n- `str_squish()` also removes whitespace from the start and end, and reduces any internal whitespace to a single space.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ntext <- \"  this   has  a lot of   whitespace   \"\nstr_trim(text)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"this   has  a lot of   whitespace\"\n```\n\n\n:::\n\n```{.r .cell-code}\nstr_squish(text)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"this has a lot of whitespace\"\n```\n\n\n:::\n:::\n\n\n# Pattern Matching\n\n- The real power of `stringr` comes from pattern matching with **regular expressions**.\n- We'll cover these in the next lecture!\n- Functions include:\n  - `str_detect()`: find if a pattern exists.\n  - `str_count()`: count the number of matches.\n  - `str_replace()`: replace matches with a new string.\n  - `str_extract()`: pull out the matching text.\n\n# Practice\n\nLet's practice working with strings!\n\n# Summary\n\n## Strings\n\n- The `stringr` package provides a consistent set of tools for working with strings.\n- Create strings with `str_c()` and `str_glue()`.\n- Extract data with `tidyr::separate_*()` functions.\n- Manipulate letters with `str_length()`, `str_sub()`, `str_to_*()`, and `str_trim()`/`str_squish()`.\n- The next step is to master pattern matching with regular expressions.",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-after-body": [
        "\n<script>\n  // htmlwidgets need to know to resize themselves when slides are shown/hidden.\n  // Fire the \"slideenter\" event (handled by htmlwidgets.js) when the current\n  // slide changes (different for each slide format).\n  (function () {\n    // dispatch for htmlwidgets\n    function fireSlideEnter() {\n      const event = window.document.createEvent(\"Event\");\n      event.initEvent(\"slideenter\", true, true);\n      window.document.dispatchEvent(event);\n    }\n\n    function fireSlideChanged(previousSlide, currentSlide) {\n      fireSlideEnter();\n\n      // dispatch for shiny\n      if (window.jQuery) {\n        if (previousSlide) {\n          window.jQuery(previousSlide).trigger(\"hidden\");\n        }\n        if (currentSlide) {\n          window.jQuery(currentSlide).trigger(\"shown\");\n        }\n      }\n    }\n\n    // hookup for slidy\n    if (window.w3c_slidy) {\n      window.w3c_slidy.add_observer(function (slide_num) {\n        // slide_num starts at position 1\n        fireSlideChanged(null, w3c_slidy.slides[slide_num - 1]);\n      });\n    }\n\n  })();\n</script>\n\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}