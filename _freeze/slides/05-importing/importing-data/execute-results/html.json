{
  "hash": "a58cb2b43dcdd82d6d35da7f3a1f2bcf",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: Importing Data\nsubtitle: \"Lecture 5\"\ntitle-slide-attributes:\n  data-background-image: ../vizdata-bg.png\n  data-background-size: stretch\n  data-slide-number: none\nformat: revealjs\n---\n\n## This lesson\n\n-   Learn how to import data into R using the `readr` package.\n-   Understand how `readr` parses files and how to control it.\n-   Learn how to write data from R back to a file.\n-   Become aware of other packages for importing different file types.\n\n## The `readr` package\n\n-   Part of the `tidyverse`, `readr` provides functions for reading rectangular data from delimited files (like CSVs).\n-   It's fast, consistent, and produces `tibble`s.\n-   It provides detailed information about how files were parsed.\n\n## Setup\n\nWe'll use functions from `readr`, which is loaded with the `tidyverse`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\n```\n:::\n\n\n## Reading delimited data\n\nThe most common function is `read_csv()` for comma-separated values.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstudents <- read_csv(\"\n  student_id, name, major\n  1, 'Alice', 'Statistics'\n  2, 'Bob', 'Computer Science'\n  3, 'Charlie', 'Data Science'\n\")\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nRows: 3 Columns: 3\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \",\"\nchr (2): name, major\ndbl (1): student_id\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n```\n\n\n:::\n\n```{.r .cell-code}\nstudents\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 3 × 3\n  student_id name      major             \n       <dbl> <chr>     <chr>             \n1          1 'Alice'   'Statistics'      \n2          2 'Bob'     'Computer Science'\n3          3 'Charlie' 'Data Science'    \n```\n\n\n:::\n:::\n\n`read_csv()` prints the column specification, which is its guess for each column's type.\n\n## Other delimiters\n\n`readr` provides functions for other common delimiters:\n- `read_csv2()`: For semicolon-separated files. Common in European countries.\n- `read_tsv()`: For tab-separated files.\n- `read_delim()`: For files with any delimiter.\n\n## Parsing & Column Specification\n\n`readr` tries to be clever and guess column types by looking at the first 1000 rows. Sometimes, it guesses wrong.\n\nConsider this file where a numeric code should be a character string:\n\n::: {.cell}\n\n```{.r .cell-code}\nchallenge <- read_csv(\"\n  x,y\n  1,A\n  2,B\n  03,C\n\")\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nRows: 3 Columns: 2\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \",\"\nchr (2): x, y\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n```\n\n\n:::\n\n```{.r .cell-code}\nchallenge\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 3 × 2\n  x     y    \n  <chr> <chr>\n1 1     A    \n2 2     B    \n3 03    C    \n```\n\n\n:::\n:::\n\nThe leading zero in `03` is dropped because `x` was parsed as a number.\n\n## Manually specifying column types\n\nYou can override `readr`'s guesses using the `col_types` argument.\n\nYou can use a compact string:\n- `c` = character\n- `d` = double\n- `i` = integer\n- `l` = logical\n- `f` = factor\n- `_` = skip column\n\n\n::: {.cell}\n\n```{.r .cell-code}\nchallenge_fixed <- read_csv(\"\n  x,y\n  1,A\n  2,B\n  03,C\n\", col_types = \"cc\") # Treat both columns as character\nchallenge_fixed\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 3 × 2\n  x     y    \n  <chr> <chr>\n1 1     A    \n2 2     B    \n3 03    C    \n```\n\n\n:::\n:::\n\n\n## Other common import options\n\n- `skip = n`: Skip the first `n` lines (useful for files with metadata at the top).\n- `comment = \"#\"`: Drop all lines that start with `#`.\n- `col_names = FALSE`: If your file has no column headers. `readr` will label them `X1`, `X2`, etc.\n- `na = \"...\"`: Specify which strings should be treated as missing values (e.g., `na = \"N/A\"`).\n\nExample with `skip`:\n\n::: {.cell}\n\n```{.r .cell-code}\nread_csv(\"\n  This is metadata\n  That we want to skip\n  x,y\n  1,2\n\", skip = 2)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning: One or more parsing issues, call `problems()` on your data frame for details,\ne.g.:\n  dat <- vroom(...)\n  problems(dat)\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nRows: 2 Columns: 1\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \",\"\nchr (1): That we want to skip\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 2 × 1\n  `That we want to skip`\n  <chr>                 \n1 x,y                   \n2 1,2                   \n```\n\n\n:::\n:::\n\n\n## Writing to a file\n\nTo save a data frame back to a file, use `write_csv()`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nwrite_csv(students, \"students.csv\")\n```\n:::\n\n- `write_csv()` is fast and efficient.\n- It encodes strings in UTF-8.\n- It does **not** write row names, which is a common source of error with base R's `write.csv()`.\n\n## Saving and loading R objects\n\nFor saving intermediate R objects, `write_csv()` is not ideal because it loses type information (e.g., factors become characters).\n\nIt's better to use `write_rds()` and `read_rds()` to save and load a single R object in R's native RDS format.\n\n::: {.cell}\n\n```{.r .cell-code}\nwrite_rds(students, \"students.rds\")\nrestored_students <- read_rds(\"students.rds\")\n```\n:::\n\n\n## Other data sources\n\nThe `tidyverse` ecosystem has packages for many other data types:\n- **`readxl`**: For Excel files (`.xls`, `.xlsx`).\n- **`haven`**: For other statistical formats (SPSS, Stata, SAS).\n- **`DBI`**: To interface with relational databases.\n- **`arrow`**: For high-performance binary formats like Parquet and Feather.\n\n## Summary\n\n-   `read_csv()` is your go-to for reading delimited text files.\n-   **Always** check the column specifications that `readr` prints. If they're wrong, fix them with `col_types`.\n-   Use `write_csv()` to save your data frames to CSV files for sharing.\n-   Use `write_rds()` to save R objects for later use in R.\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-after-body": [
        "\n<script>\n  // htmlwidgets need to know to resize themselves when slides are shown/hidden.\n  // Fire the \"slideenter\" event (handled by htmlwidgets.js) when the current\n  // slide changes (different for each slide format).\n  (function () {\n    // dispatch for htmlwidgets\n    function fireSlideEnter() {\n      const event = window.document.createEvent(\"Event\");\n      event.initEvent(\"slideenter\", true, true);\n      window.document.dispatchEvent(event);\n    }\n\n    function fireSlideChanged(previousSlide, currentSlide) {\n      fireSlideEnter();\n\n      // dispatch for shiny\n      if (window.jQuery) {\n        if (previousSlide) {\n          window.jQuery(previousSlide).trigger(\"hidden\");\n        }\n        if (currentSlide) {\n          window.jQuery(currentSlide).trigger(\"shown\");\n        }\n      }\n    }\n\n    // hookup for slidy\n    if (window.w3c_slidy) {\n      window.w3c_slidy.add_observer(function (slide_num) {\n        // slide_num starts at position 1\n        fireSlideChanged(null, w3c_slidy.slides[slide_num - 1]);\n      });\n    }\n\n  })();\n</script>\n\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}