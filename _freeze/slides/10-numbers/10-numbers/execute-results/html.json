{
  "hash": "d9fe27281627ac86194d48ca35fda827",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Numbers\"\nsubtitle: \"Lecture 10\"\ntitle-slide-attributes:\n  data-background-image: ../vizdata-bg.png\n  data-background-size: stretch\n  data-slide-number: none\nformat: revealjs\n---\n\n\n::: {.cell}\n\n:::\n\n\n# Introduction\n\n## Working with Numbers\n\n- Numeric data is the most common type of data you'll work with.\n- This lecture covers creating, transforming, and summarizing numeric vectors.\n- We'll use functions from base R and `dplyr`.\n\n# Creating Numbers\n\n## Parsing Numbers\n\n- Sometimes numbers are stored as text (strings).\n- `readr::parse_double()` converts strings to numbers, assuming they are just numbers.\n- `readr::parse_number()` is more flexible and can extract numbers from strings with other text.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nparse_double(\"1.23\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1.23\n```\n\n\n:::\n\n```{.r .cell-code}\nparse_number(\"$1,234.50\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1234.5\n```\n\n\n:::\n\n```{.r .cell-code}\nparse_number(\"55%\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 55\n```\n\n\n:::\n:::\n\n\n# Counts\n\n## `count()`\n\n- `dplyr::count()` is a quick way to count the number of rows for each unique value of a variable.\n- It's a shortcut for `group_by()` and `summarize(n = n())`.\n\n## Example\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# Count flights per destination\nflights |> count(dest, sort = TRUE)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 105 × 2\n   dest      n\n   <chr> <int>\n 1 ORD   17283\n 2 ATL   17215\n 3 LAX   16174\n 4 BOS   15508\n 5 MCO   14082\n 6 CLT   14064\n 7 SFO   13331\n 8 FLL   12055\n 9 MIA   11728\n10 DCA    9705\n# ℹ 95 more rows\n```\n\n\n:::\n:::\n\n\n## Weighted Counts\n\n- You can provide a weight to `count()` to sum up a variable instead of just counting rows.\n- This is useful for summarizing pre-counted data.\n\n## Example\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ndf <- tribble(\n  ~group, ~subgroup, ~n,\n  \"a\",    \"1\",       2,\n  \"a\",    \"2\",       5,\n  \"b\",    \"1\",       3\n)\n\n# Sum of `n` for each `group`\ndf |> count(group, wt = n)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 2 × 2\n  group     n\n  <chr> <dbl>\n1 a         7\n2 b         3\n```\n\n\n:::\n:::\n\n\n## Practice\n\nLet's do some practice!\n\n# Arithmetic\n\n## Basic Operators\n\n- R provides the standard arithmetic operators: `+`, `-`, `*`, `/`, `^`.\n- `%%` (remainder) and `%/%` (integer division) are useful for modular arithmetic.\n\n## Example\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code  code-fold=\"true\"}\n# Break down departure time into hour and minute\nflights |> \n  select(dep_time) |>\n  mutate(\n    hour = dep_time %/% 100,\n    minute = dep_time %% 100,\n    total_minutes = hour * 60 + minute\n  )\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 336,776 × 4\n   dep_time  hour minute total_minutes\n      <int> <dbl>  <dbl>         <dbl>\n 1      517     5     17           317\n 2      533     5     33           333\n 3      542     5     42           342\n 4      544     5     44           344\n 5      554     5     54           354\n 6      554     5     54           354\n 7      555     5     55           355\n 8      557     5     57           357\n 9      557     5     57           357\n10      558     5     58           358\n# ℹ 336,766 more rows\n```\n\n\n:::\n:::\n\n\n# Transformations\n\n## Logarithms\n\n- Logarithms (`log()`, `log2()`, `log10()`) are useful for data that spans multiple orders of magnitude.\n- They help turn exponential growth into linear growth, which is often easier to model.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code  code-fold=\"true\"}\nggplot(diamonds, aes(x = carat, y = price)) +\n  geom_point(alpha = 0.1) +\n  scale_x_log10() +\n  scale_y_log10() +\n  labs(title = \"Price vs. Carat (log-log scale)\")\n```\n\n::: {.cell-output-display}\n![](10-numbers_files/figure-revealjs/unnamed-chunk-5-1.png){fig-align='center' width=2100}\n:::\n:::\n\n\n## Rounding\n\n- `round(x)`: rounds to the nearest integer.\n- `floor(x)`: always rounds down.\n- `ceiling(x)`: always rounds up.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nx <- c(1.2, 1.5, 1.8)\nround(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1 2 2\n```\n\n\n:::\n\n```{.r .cell-code}\nfloor(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1 1 1\n```\n\n\n:::\n\n```{.r .cell-code}\nceiling(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 2 2 2\n```\n\n\n:::\n:::\n\n\n## Cutting\n\n- `cut()` divides a numeric vector into a set of discrete bins (a factor).\n- You can specify the `breaks` for the bins.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nx <- c(1, 2, 5, 7, 10, 12)\ncut(x, breaks = c(0, 5, 10, 15))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] (0,5]   (0,5]   (0,5]   (5,10]  (5,10]  (10,15]\nLevels: (0,5] (5,10] (10,15]\n```\n\n\n:::\n:::\n\n\n# Ranks & Offsets\n\n## Ranks\n\n- `dplyr::min_rank()` gives ranks, handling ties by giving them the same rank.\n- Use `desc()` to rank from highest to lowest.\n- `row_number()` is similar but gives each row a unique rank.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nx <- c(5, 1, 3, 2, 2)\nmin_rank(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 5 1 4 2 2\n```\n\n\n:::\n\n```{.r .cell-code}\nrow_number(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 5 1 4 2 3\n```\n\n\n:::\n:::\n\n\n## Offsets\n\n- `dplyr::lag()` gets the previous value in a vector.\n- `dplyr::lead()` gets the next value.\n- Useful for computing differences or finding changes.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nx <- c(2, 5, 11, 20)\n# Difference between each element and the previous one\nx - lag(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] NA  3  6  9\n```\n\n\n:::\n:::\n\n\n\n## Practice!\n\nLet's practice some arithmetic operations and trasnformations!\n\n\n# Numeric Summaries\n\n## Center\n\n- `mean()`: the average value. Can be sensitive to outliers.\n- `median()`: the middle value. More robust to outliers.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code  code-fold=\"true\"}\n# Comparing mean and median delay\nflights |>\n  filter(!is.na(dep_delay)) |>\n  summarize(\n    mean_delay = mean(dep_delay),\n    median_delay = median(dep_delay)\n  )\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 1 × 2\n  mean_delay median_delay\n       <dbl>        <dbl>\n1       12.6           -2\n```\n\n\n:::\n:::\n\n\n## Spread\n\n- `sd()`: standard deviation, measures how spread out the data is around the mean.\n- `IQR()`: interquartile range (`Q3 - Q1`), measures the spread of the middle 50% of the data.\n\n## Position\n\n- `min()` and `max()`: the minimum and maximum values.\n- `quantile(x, p)`: finds the value that is greater than `p`% of the data.\n  - `quantile(x, 0.25)` is the 25th percentile (Q1).\n  - `median(x)` is a shortcut for `quantile(x, 0.5)`.\n\n# Practice\n\nLet's practice working with numbers!\n\n# Summary\n\n## Numbers\n\n- Create with `parse_number()`.\n- Transform with arithmetic, logs, rounding, and `cut()`.\n- `count()` is a powerful tool for quick exploration.\n- Use ranks (`min_rank`) and offsets (`lag`, `lead`) for more complex analysis.\n- Summarize with measures of center (`mean`, `median`), spread (`sd`, `IQR`), and position (`min`, `max`, `quantile`).\n",
    "supporting": [
      "10-numbers_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-after-body": [
        "\n<script>\n  // htmlwidgets need to know to resize themselves when slides are shown/hidden.\n  // Fire the \"slideenter\" event (handled by htmlwidgets.js) when the current\n  // slide changes (different for each slide format).\n  (function () {\n    // dispatch for htmlwidgets\n    function fireSlideEnter() {\n      const event = window.document.createEvent(\"Event\");\n      event.initEvent(\"slideenter\", true, true);\n      window.document.dispatchEvent(event);\n    }\n\n    function fireSlideChanged(previousSlide, currentSlide) {\n      fireSlideEnter();\n\n      // dispatch for shiny\n      if (window.jQuery) {\n        if (previousSlide) {\n          window.jQuery(previousSlide).trigger(\"hidden\");\n        }\n        if (currentSlide) {\n          window.jQuery(currentSlide).trigger(\"shown\");\n        }\n      }\n    }\n\n    // hookup for slidy\n    if (window.w3c_slidy) {\n      window.w3c_slidy.add_observer(function (slide_num) {\n        // slide_num starts at position 1\n        fireSlideChanged(null, w3c_slidy.slides[slide_num - 1]);\n      });\n    }\n\n  })();\n</script>\n\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}