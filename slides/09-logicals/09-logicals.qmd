---
title: "Logical Vectors"
subtitle: "Lecture 9"
title-slide-attributes:
  data-background-image: ../vizdata-bg.png
  data-background-size: stretch
  data-slide-number: none
format: revealjs
---

```{r}
#| label: setup
#| message: false
#| echo: false

# load packages
library(tidyverse)
library(nycflights13)

# set theme for ggplot2
ggplot2::theme_set(ggplot2::theme_minimal(base_size = 14))

# set figure parameters for knitr
knitr::opts_chunk$set(
  fig.width = 7,
  fig.asp = 0.618,
  fig.retina = 3,
  fig.align = "center",
  dpi = 300
)
```

# Introduction

## Logical Vectors

- A logical vector is a vector that contains only `TRUE`, `FALSE`, and `NA` (missing) values.
- They are rarely in your raw data, but you will create and use them in almost every analysis.
- Logical vectors are the foundation of filtering and conditional transformations.

# Comparisons

## Creating Logicals

- You can create logical vectors with comparison operators:
  - `>` (greater than), `<` (less than)
  - `>=` (greater than or equal to), `<=` (less than or equal to)
  - `==` (equal to), `!=` (not equal to)

```{r}
#| echo: true
x <- c(1, 2, 3, 5, 8, 13)
x > 4
```

## Comparisons with `filter()`

- Most often, you'll use comparisons inside `filter()` to select rows.

```{r}
#| echo: true
#| code-fold: true
# Flights that departed in January
filter(flights, month == 1)
```

## Floating Point Comparison

- Be careful when using `==` with numbers. Computers can have small rounding errors.
- Use `dplyr::near()` to compare two numbers for "close enough" equality.

```{r}
#| echo: true
# This might be FALSE due to floating point math!
1/3 * 3 == 1

# This is a safer way to compare
near(1/3 * 3, 1)
```

# Missing Values

## `NA`

- `NA` represents a missing value.
- `NA` is "contagious": almost any operation involving `NA` will produce `NA`.
- You can't use `==` to find missing values.

```{r}
#| echo: true
NA > 5
NA == 10
NA == NA
```

## `is.na()`

- Use the `is.na()` function to test if a value is missing.

```{r}
#| echo: true
x <- c(1, NA, 3)
is.na(x)
```

## Filtering and `NA`

- `filter()` only includes rows where the condition is `TRUE`. It excludes `FALSE` and `NA` values.
- If you want to include missing values in your filter, you must ask for them explicitly.

```{r}
#| echo: true
#| code-fold: true
df <- tibble(x = c(1, NA, 3))

# This only keeps the row where x > 1 is TRUE
filter(df, x > 1)

# To keep NA values, you have to say so
filter(df, x > 1 | is.na(x))
```

# Boolean Algebra

## Combining Conditions

- You can combine multiple logical conditions using boolean operators:
  - `&` (and)
  - `|` (or)
  - `!` (not)

```{r}
#| echo: true
#| code-fold: true
# Flights in January or February
filter(flights, month == 1 | month == 2)

# Flights not delayed (on departure or arrival)
filter(flights, !(dep_delay > 0 | arr_delay > 0))
```

## `%in%`

- A useful shortcut for `x == a | x == b | x == c` is `x %in% c(a, b, c)`.
- It checks if each value in the left vector is present in the right vector.

```{r}
#| echo: true
#| code-fold: true
# Flights in November or December
filter(flights, month %in% c(11, 12))
```

# Summarizing Logicals

## Logical Summaries

- `any()`: returns `TRUE` if there is at least one `TRUE`.
- `all()`: returns `TRUE` if all values are `TRUE`.
- Use `na.rm = TRUE` to ignore missing values.

```{r}
#| echo: true
x <- c(TRUE, FALSE, NA)
any(x)
all(x, na.rm = TRUE)
```

## Numeric Summaries

- When you use a logical vector in a numeric context, `TRUE` becomes `1` and `FALSE` becomes `0`.
- `sum()`: counts the number of `TRUE`s.
- `mean()`: calculates the proportion of `TRUE`s.

```{r}
#| echo: true
#| code-fold: true
# How many flights were delayed on arrival by more than an hour?
sum(flights$arr_delay > 60, na.rm = TRUE)

# What proportion of flights were delayed?
mean(flights$arr_delay > 0, na.rm = TRUE)
```

# Conditional Transformations

## `if_else()`

- `if_else(condition, value_if_true, value_if_false)`
- A safe and strict version of `if` that works well inside `mutate()`.
- All output values must be of the same type.

```{r}
#| echo: true
x <- c(-3, -1, 0, 1, 3)
if_else(x > 0, "positive", "negative or zero")
```

## `case_when()`

- For multiple conditions, `case_when()` is easier to read than nested `if_else()`.
- `case_when(condition1 ~ value1, condition2 ~ value2, ...)`
- The first `TRUE` condition wins.

```{r}
#| echo: true
#| code-fold: true
case_when(
  x < 0 ~ "negative",
  x == 0 ~ "zero",
  x > 0 ~ "positive"
)
```

## Example: `case_when()`

- Let's create a human-readable "season" variable.

```{r}
#| echo: true
#| code-fold: true
flights |>
  mutate(
    season = case_when(
      month %in% c(12, 1, 2) ~ "Winter",
      month %in% c(3, 4, 5) ~ "Spring",
      month %in% c(6, 7, 8) ~ "Summer",
      month %in% c(9, 10, 11) ~ "Fall"
    )
  ) |>
  select(month, season)
```

# Practice

Let's practice with logical vectors!

# Summary

## Logical Vectors

- Create with comparisons: `<`, `==`, `%in%`, `is.na()`.
- Combine with boolean operators: `&`, `|`, `!`.
- Summarize with `any()`, `all()`, `sum()`, `mean()`.
- Use for conditional transformations with `if_else()` and `case_when()`.
- Logical vectors are a fundamental tool for data manipulation in R.
